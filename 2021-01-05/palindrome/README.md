## 1. 문제

### 원하는 것

소문자 알파벳으로만 이루어진 한 단어(띄어쓰기 포함되지 않음)가 주어졌을 때 이 단어가 회문인지 판단하는 프로그램을 만들어라

```
<입력과 출력 예>
a => true
ab => false
aba => true
rotator => true
ashal => false
```

### 자료

* 소문자 알파벳으로만 이루어졌다.
* 띄어쓰기는 존재하지 않는다.
* 문자열을 뒤집어도 입력한 문자열과 같아야한다.
* 좌우 대칭이니까 쌍을 이루는 문자열이 존재할 수도 있다.

### 비슷한 문제

무언가 쌍을 맞추는 느낌이 들어서 괄호가 올바르게 닫혔는지 확인하는 프로그램이랑 비슷한 것 같다.

## 2. 계획

```
2개의 인덱스를 준비한다.
하나는 왼쪽에서 부터 하나는 오른쪽에서 부터 시작한다.
if 왼쪽의 인덱스가 오른쪽보다 같거나 크면 
  참을 반환한다.
else 왼쪽의 인덱스가 오른쪽보다 작으면
  인덱스가 가리키는 값을 비교한다.
  if 가리키는 값이 같으면
    왼쪽은 오른쪽으로 한칸, 오른쪽은 왼쪽으로 한 칸 이동한다.
    위의 과정을 반복한다.
  else 다르면
    거짓을 반환한다.
```

## 3. 실행

## 4. 회고

생각했던대로 잘 됐다.

### 더 쉽게 푸는 방법

reverse를 사용하면 쉬울 것 같다.

### 더 잘 푸는 방법

함수로 더 작게 쪼개서 TDD단계를 더 세밀하게 했어야 할까? 생각이 든다.
'abba'가 주어졌을 때 `string[0] === string[3] && string[1] === string[2]`까지 정답으로부터 추출해내고 다시 `string[left] === string[right] && string[left + 1] === string[right - 1]`까지 추출했지만 여기서 한 번에 재귀로 풀었던 것 같다.  

앞으로 더 작게 과정을 쪼개는 연습을 의도적으로 해야겠다.

### 어디에 적용할 수 있을까?

앞에서 순서대로 zip을 하는 것이 아닌 앞과 뒤에서 짝을 이루는 Pair를 만드는 zip을 만든다면 이런 모양이지 않을까?
