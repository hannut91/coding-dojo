/**
 * ## 이해
 *
 * 미지의 것: 손님이 원하는 떡의 길이만큼 얻기 위해 절단기에 설정할 수 있는 높이의 최대값을 구하여라
 * 자료
 *   - 떡을 자르고 남은 것의 총 합을 손님이 가져가는 떡이다.
 *   - 떡을 크기로 잘라보아야 손님에게 줄 수 있는 떡의 양을 측정할 수 있다.
 *   - 가장 긴 떡 보다 더 높은 크기로 자를 필요 없다. 왜냐하면 손님은 길이가 0인
 *     떡을 받을수는 없기 때문이다. 최소한 1보다 크거나 같아야 문제가 정의된다.
 * 조건
 *   - 배열이 정렬되어 있지 않다.
 *
 * ## 계획
 *   - 최소, 최대로 자를 수 있는 떡의 중간 크기로 떡을 잘라본다.
 *   - 만약 원하는 떡의 양만큼 잘라졌다면, 크기를 반환한다.
 *   - 원하는 양 보다 많다면, 더 많이 잘라야 하므로 중간보다 크고 최대 보다 작은 범위에서 찾는다.
 *   - 원하는 양 보다 적다면, 덜 잘라야 하므로 최소보다 크고 중간보다 작은 범위에서 찾는다.
 *
 * ## 실행
 *
 * ## 반성
 *   - 문제를 제대로 읽지 않아서 적어도 N만큼의 떡이 있어야 한다는 것을 놓쳐서
 *     예외케이스가 틀렸다. 그래도 끝나고 나서 그냥 넘어가는 것이 아니라 이것저것 테스트를 해봐서 문제를 찾아낼 수 있었다.
 */

const cut = (arr, size) => arr.reduce((acc, cur) => (acc + ((cur - size > 0) ? (cur - size) : 0)), 0);

const run = (arr, target) => {
  let start = 0;
  let end = 1000000000;

  while (true) {
    const mid = Math.floor((start + end) / 2);
    const size = cut(arr, mid);
    if (size === target) {
      return mid;
    }

    if (start > end) {
      return mid;
    }

    if (size > target) {
      start = mid + 1;
    } else {
      end = mid - 1;
    }
  }
};

test('run', () => {
  expect(run([19, 15, 10, 17], 1)).toBe(18);
  expect(run([19, 15, 10, 17], 2)).toBe(17);
  expect(run([19, 15, 10, 17], 3)).toBe(16);
  expect(run([19, 15, 10, 17], 6)).toBe(15);
  expect(run([19, 15, 10, 17], 7)).toBe(14);
  expect(run([19, 15, 10, 17], 13)).toBe(12);
  expect(run([19, 15, 10, 17], 14)).toBe(12);
  expect(run([19, 15, 10, 17], 15)).toBe(12);
  expect(run([19, 15, 10, 17], 16)).toBe(11);
  expect(run([19, 15, 10, 17], 17)).toBe(11);
  expect(run([19, 15, 10, 17], 18)).toBe(11);
  expect(run([19, 15, 10, 17], 19)).toBe(10);
});
