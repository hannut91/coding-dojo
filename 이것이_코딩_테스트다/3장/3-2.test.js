// 원하는 것: 배열, 숫자가 더해지는 횟수 M 그리고 K가 주어질 때 동비닝의 큰 수의 법칙에 따른 결과를 출력하라
// 자료:
//  동빈이의 큰 수의 법칙은 다양한 수로 이루어진 배열이 있을 대 주어진 수들을 M번 더하여 가장 큰 수를 만드는 법칙이다.
//  주어진 숫자중에서 가장 큰 숫자를 K번 반복하는 것이 가장 큰 수다.
//  연속되지만 않으면 되므로 K번 반복하고, 그 다음으로 큰 수 한 번 더하고 다시
//  K번 반복했을 때 가장 큰수가 된다.

// 조건:
//   배열의 특정한 인덱스에 해당하는 수가 연속해서 K번 초과하여 더해질 수 없다.
//   서로 다른 인덱스에 해당하는 수가 같은 경우에도 서로 다른 것으로 간주한다.

// 계획
// 가장 큰 수와 그 다음으로 큰 수를 구한다.
// 남은 수가 K보다 작다면
//   가장 큰 수 * K를 반환한다.
// M을 K + 1로 나눈다
// ((가장 큰 수 * K) + 다음 큰 수) * 몫 + 나머지 * 가장 큰 수를 반환한다.

// 실행

// 반성
// 코드 짜다가 복잡한 수 계산이 나와서 계획이 잘 작성되지 않았다. 편한 재귀로
// 먼저 풀고나서 수식으로 바꿀려다가, 패턴이 보이는 것 같아서 수식으로 풀었다.
// 수식 작성중에 실수한 것이 있어서, 운이 나쁘게도 우연히 결과가 맞게 나와서
// 틀릴뻔 했다.
// 수식으로 문제를 풀 때는 변수에 직접 숫자를 넣어보면서 올바른 값들을
// 입력했는지 다시 한 번 검증해야겠다. 아마 재귀로도 충분히 풀 수 있을 것 같다.

// 수식으로 풀기
// const run = (arr, m, k) => {
//   const [max, next] = [...arr].sort((a, b) => b - a);
//   const quotient = Math.floor(m / (k + 1));
//   const remain = m % (k + 1);
//   return (((max * k) + next) * quotient) + (remain * max);
// };

// 재귀로 풀기
const r = (max, next, m, k, count = 0) => {
  if (m === 0) {
    return count;
  }

  if (m >= k + 1) {
    return r(max, next, m - (k + 1), k, count + ((max * k) + next));
  }

  return r(max, next, 0, k, count + (max * m));
};

const run = (arr, m, k) => {
  const [max, next] = [...arr].sort((a, b) => b - a);
  return r(max, next, m, k);
};

test('run', () => {
  expect(run([2, 4, 5, 4, 6], 8, 3)).toBe(46);
  expect(run([2, 4, 5, 4, 6], 8, 4)).toBe(47);
  expect(run([2, 4, 5, 4, 6], 8, 2)).toBe(46);
});
