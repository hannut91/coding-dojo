/**
 * ## 이해
 *
 * 미지의 것: 두 배열의 원소를 K번 바꿔치기 했을 떄 최대값을 구하여라
 * 자료
 *   - 두 배열이 있다.
 *   - A배열에서 가장 작은 값을 B배열의 가장 큰 값으로 대체해야 한다.
 * 조건
 *   -
 *
 * ## 계획
 *   - A는 오름차순, B는 내림차순으로 정렬한다.
 *   - K번 B요소의 같은 인덱스에 해당하는 값을 A배열로 복사한다.
 *   - 합을 반환한다.
 *
 * ## 실행
 *
 * ## 반성
 *  - A배열에서 가장 작은 값을 B배열의 가장 큰 값으로 대체해야 한다. 그러면
 *    A에서 가장 작은 값은 어떻게 찾고 B에서 가장 큰 값을 어떻게 찾아야 하는지 알아야 한다.
 *  - 문제에서 최대 K수 만큼만 바꾼다고 했으니, 만약 B에서 A의 합이 더 이상 커질
 *    수 없다면 더하지 않아야 한다. 이를 실수했었는데 테스트 케이스를 추가해서
 *    찾을 수 있었다. 정답이 나왔다고 하더라도 예외 케이스를 더 찾아봐야겠다.
 */

const sum = arr => arr.reduce((acc, cur) => acc + cur, 0);

const r = (a, b, k, index = 0) => {
  if (index === k) {
    return sum(a);
  }

  if (a[index] >= b[index]) {
    return sum(a);
  }

  a[index] = b[index];

  return r(
    a,
    b,
    k,
    index + 1,
  );
};

// 재귀를 이용
const run = (a, b, k) => {
  const left = [...a].sort((a, b) => a - b);
  const right = [...b].sort((a, b) => b - a);
  return r(left, right, k);
};

test('run', () => {
  expect(run([1, 2, 5, 4, 3], [5, 5, 6, 6, 5], 1)).toBe(20);
  expect(run([1, 2, 5, 4, 3], [5, 5, 6, 6, 5], 2)).toBe(24);
  expect(run([1, 2, 5, 4, 3], [5, 5, 6, 6, 5], 3)).toBe(26);
  expect(run([1, 2, 5, 4, 3], [5, 5, 6, 6, 5], 5)).toBe(27);
  expect(run([1, 2, 5, 4, 3], [1, 1, 1, 1, 1], 5)).toBe(15);
});
