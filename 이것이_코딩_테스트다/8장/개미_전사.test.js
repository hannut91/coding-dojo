/**
 * ## 이해
 *
 * 미지의 것: 개미 전사가 식량을 얻을 수 있는 최댓값을 구하여라
 * 자료
 *   - 식량창고는 일직선으로 이어져 있다.
 *   - 식량창고에는 식량이 저장되어 있다.
 *   - 메뚜기 정찰병들은 일직선상에 존재하는 식량창고 중에서 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 잇다.
 *   - 개미 전사가 정찰병에게 들키지 않고 식량창고를 약탈하기 위해서는 최소한 한 칸 이상 떨어진 식량창고를 약탈해야 한다.
 * 조건
 *   -
 *
 * ## 계획
 *   - 배열 첫 번째 요소와 두 번재 요소를 선택한 것중에 가장 큰 값을 반환한다.
 *
 * ## 실행
 *
 * ## 반성
 *   - 처음에 막막하다고 생각했었는데, 모든 경우의 수를 나열해보자고 했더니
 *     방향성이 나왔다. 머리로만 생각하니 안될 것 같았는데, 일단 나열해보니 보였다.
 *   - 예제가 너무 단순해서 검증하기가 어려웠는데, 내 생각을 충분히 검증할 수
 *     있는 예제를 만들어서 검증하여 문제를 해결했다.
 *   - 효율성을 체크하고 메모이제이션을 통해 최적화를 해봐야겠다.
 */

// [1, 3, 1, 5]
// [1, 3, 1, 5, 20, 3, 1, 5]
// 1, 1, 20, 1
// 3, 5, 3, 5
// 3, 20, 5

// 1                          3
// [1, 5, 20, 3, 1, 5]       [5, 20, 3, 1, 5]
// 1              5           5         20
// [20, 3, 15]    [3, 1, 5]   [3, 1, 5] [1, 5]
// 20        3    3     1     3   1      1    5
// [1, 5]   [5]   [5]   []    [5] []     []  []
// 15        5                5
// 1    5    []               []
// []   []

const cache = {
};

const run = arr => {
  if (cache[arr]) {
    return cache[arr];
  }

  if (arr.length === 0) {
    return 0;
  }

  if (arr.length === 1) {
    return arr[0];
  }

  cache[arr] = Math.max(
    run(arr.slice(2)) + arr[0],
    run(arr.slice(3)) + arr[1],
  );
  return cache[arr];
};

test('run', () => {
  expect(run([1, 3, 1, 5, 20, 3, 1, 5])).toBe(28);
});
