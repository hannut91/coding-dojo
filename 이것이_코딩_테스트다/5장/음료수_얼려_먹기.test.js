/**
 * ## 이해
 *
 * 미지의 것: 얼음 틀의 모양이 주어졌을 때 생성되는 총 아이스크림의 개수를 구하여라
 * 자료
 *   - 구멍이 뚫려 있는 부분은 0
 *   - 칸막이가 존재하는 부분은 1
 *   - 구멍이 뚫려 있는 부분끼리 상, 하, 좌, 우로 붙어 있는 경우 서로 연결되어 있는 것으로 간주한다
 *   - N * M을 그래프로 바라볼 수 있다.
 *   - 그래프는 탐색할 수 있다.
 *   - 그래프는 탐색할 때 방문한 곳과 방문하지 않은 곳을 구분해서 방문한다.
 *   - 그래프는 인접행렬 혹은 인접 리스트로 표현할 수 있다.
 *
 * 조건
 *   -
 *
 * ## 계획
 *   - 매트릭스를 만든다. 이 때 방문했는지 안했는지를 값을 가지고 있도록 한다.
 *   - [0, 0]부터 시작해서 BFS를 하여 탐색한다.
 *   -   만약 현재 위치가 1이라면 다음 노드로 넘어간다.
 *
 * ## 실행
 *
 * ## 반성
 *
 */

// 인접리스트
const directions = [
  ([x, y]) => [x + 1, y],
  ([x, y]) => [x - 1, y],
  ([x, y]) => [x, y + 1],
  ([x, y]) => [x, y - 1],
];

const getNodes = (matrix, point) => {
  const height = matrix.length;
  const width = matrix[0].length;
  return directions.map(direction => direction(point))
    .filter(([x, y]) => {
      if (x < 0 || y < 0 || x >= width || y >= height) {
        return false;
      }

      if (matrix[y][x][1] === 1) {
        return false;
      }

      if (matrix[y][x][0] === 1) {
        return false;
      }

      return true;
    });
};

const findStartPoint = matrix => {
  for (let y = 0; y < matrix.length; y++) {
    const index = matrix[y].findIndex(col => col[0] === 0 && col[1] === 0);
    if (index >= 0) {
      return [index, y];
    }
  }

  return null;
};

const convertMatrix = matrix => matrix.map(rows =>
  rows.map(col => [col, 0]));

const bfs = (matrix, startPoint) => {
  const queue = [];
  queue.push(startPoint);
  while (true) {
    if (queue.length === 0) {
      return matrix;
    }

    const [x, y] = queue.shift();
    if (matrix[y][x][1] === 1) {
      continue;
    }

    matrix[y][x][1] = 1;

    const nodes = getNodes(matrix, [x, y]);
    nodes.forEach(node => {
      queue.push(node);
    });
  }
};

const run = matrix => {
  const convertedMatrix = convertMatrix(matrix);

  let count = 0;
  while (true) {
    const point = findStartPoint(convertedMatrix);
    if (!point) {
      return count;
    }
    count++;
    bfs(convertedMatrix, point);
  }
};

test('test', () => {
  expect(run(
    [
      [0, 0, 1, 1, 0],
      [0, 0, 0, 1, 1],
      [1, 1, 1, 1, 1],
      [1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0],
    ],
  )).toBe(3);

  expect(run(
    [
      [0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0],
      [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0],
      [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 1, 1, 0],
      [1, 1, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0],
      [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0],
      [1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
      [0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
      [0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0],
      [0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0],
      [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1],
      [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 0, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1],
    ],
  )).toBe(4);

  expect(run(
    [
      [0, 1, 0, 1, 0],
      [0, 0, 0, 1, 0],
      [1, 1, 1, 0, 1],
      [1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0],
    ],
  )).toBe(4);
});

test('bfs', () => {
  expect(bfs([
    [[0, 0], [0, 0], [1, 0], [1, 0], [0, 0]],
    [[0, 0], [0, 0], [0, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  ],
  [0, 0])).toEqual([
    [[0, 1], [0, 1], [1, 0], [1, 0], [0, 0]],
    [[0, 1], [0, 1], [0, 1], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  ]);

  expect(bfs([
    [[0, 0], [0, 0], [1, 0], [1, 0], [0, 0]],
    [[0, 0], [0, 0], [0, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  ],
  [4, 0])).toEqual([
    [[0, 0], [0, 0], [1, 0], [1, 0], [0, 1]],
    [[0, 0], [0, 0], [0, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  ]);

  expect(bfs([
    [[0, 0], [0, 0], [1, 0], [1, 0], [0, 0]],
    [[0, 0], [0, 0], [0, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
  ],
  [0, 4])).toEqual([
    [[0, 0], [0, 0], [1, 0], [1, 0], [0, 0]],
    [[0, 0], [0, 0], [0, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
    [[0, 1], [0, 1], [0, 1], [0, 1], [0, 1]],
  ]);
});

test('getNodes', () => {
  expect(getNodes(
    [
      [[0, 0], [0, 0], [1, 0], [1, 0], [0, 0]],
      [[0, 0], [0, 0], [0, 0], [1, 0], [1, 0]],
      [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
      [[1, 0], [1, 0], [1, 0], [1, 0], [1, 0]],
      [[0, 0], [0, 0], [0, 0], [0, 0], [0, 0]],
    ],
    [0, 0],
  )).toEqual([
    [1, 0],
    [0, 1],
  ]);
});
