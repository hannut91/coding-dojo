/**
 * ## 이해
 *
 * 미지의 것: 라이언이 가장 큰 점수 차이로 우승하기 위해 n발의 화살을 어떤 과녁 점수에 맞혀야
 * 하는지를 10점부터 0점까지 순서대로 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요
 * 자료
 *   - 라이언과 어피치 모두 k점에 단 하나의 화살도 맞히지 못한 경우는 어느 누구도 k점을 가져가지 않습니다
 *   - 같은 점수라면 어피치가 점수를 가져간다. 즉 최소 화살려고 이기려면 같은
 *     횟수를 맞춰야 한다.
 *   - 같은 점수를 여러번 맞추더라도 한 번만 가져간다.
 *   - 최종 점수가 같을 경우 어피치가 우승한다.
 * 조건
 *   -
 *
 * ## 계획
 *   - 라이언이 현재 쏠 수 있는 경우 중 가장 경우 중 가장 높은 것을 선택한다.
 *
 * ## 실행
 *
 * ## 반성
 *   - DP문젠줄알고 DP로 처음에 문제를 해결했다. 근데 DP로 안되는 경우가 있는데
 *     발견하는데 시간이 오래걸렸다. 그래서 완전 탐색으로 풀려고 했는데, 예외인
 *     경우를 고려하지 못해서 틀렸다. 이 때 정답을 제출하면 일부만 통과하는데
 *     의심 되는 부분의 코드를 지우고 다시 실행해본 것과 지우지 않고 실행한 것에
 *     차이가 있다는 것을 발견했다. 그래서 내가 의심되는 곳을 잘못 작성했다는
 *     것을 깨달았다. 그런데 테스트 코드를 작성하지 않아서 꼼꼼히 살펴보지
 *     않아서 시간이 오래 걸렸다. 쉽다고 생각하는 곳도 꼼꼼하게 테스트 해야겠다.
 */

const dfs = (n, info, result = [], score = 0, arr) => {
  if (info.length === 1) {
    arr.push([
      score,
      [...result, n],
    ]);
    return;
  }

  const a = info[0];
  if (n >= (a + 1)) {
    dfs(
      n - (a + 1),
      info.slice(1), [...result, (a + 1)],
      score + (info.length - 1),
      arr,
    );
  }

  dfs(
    n,
    info.slice(1),
    [...result, 0],
    score - (a === 0 ? 0 : (info.length - 1)),
    arr,
  );
};

const run = (n, info) => {
  const arr = [];
  dfs(n, info, [], 0, arr);

  const r = arr.reduce((acc, cur) => {
    if (acc[0] === cur[0]) {
      for (let i = cur[1].length - 1; i >= 0; i--) {
        if (cur[1][i] > acc[1][i]) {
          return cur;
        }

        if (cur[1][i] < acc[1][i]) {
          return acc;
        }
      }
      return acc;
    }

    return cur[0] > acc[0] ? cur : acc;
  }, arr[0]);
  if (r[0] <= 0) {
    return [-1];
  }
  return r[1];
};

test('run', () => {
  expect(run(
    5,
    [2, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0],
  )).toEqual([0, 2, 2, 0, 1, 0, 0, 0, 0, 0, 0]);

  expect(run(
    1,
    [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  )).toEqual([-1]);

  expect(run(
    9,
    [0, 0, 1, 2, 0, 1, 1, 1, 1, 1, 1],
  )).toEqual([1, 1, 2, 0, 1, 2, 2, 0, 0, 0, 0]);

  expect(run(
    10,
    [0, 0, 0, 0, 0, 0, 0, 0, 3, 4, 3],
  )).toEqual([1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 2]);

  expect(run(
    10,
    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
  )).toEqual([1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0]);
});
